/*
Dijkstra算法C语言实现

单源最短路径算法：指定一个点（源点）到其他各个顶点最短路径

算法的基本思想是：每次找到离源点最近的的一个顶点，然后以该顶点为中心进行扩展，最终得到源点到其他各点的最短路径

基本步骤如下：
・将所有的顶点分为两个部分：已知最短路程的顶点集合P和未知最短路径的顶点集合Q。最开始，已知最短路径的顶点集合P中
 只有源点一个顶点。我们这里用一个book[i]数组来记录哪些点在集合P中。例如对于某个顶点i，如果book[i]为1则表示这个
 顶点在集合P中，如果book[i]为0则表示这个顶点在集合Q中。
・设置源点s到自己的最短路径为0即dis=0。若存在源点有能直接到达的顶点i，则把dis[i]设为e[s][i]。同时把其他（源点不
 能直接到达的）顶点的最短路径设为∞。
・在集合Q的所有顶点中选择一个离源点S最近的顶点u（即dis[u]最小）加入到集合P。并考察所有以点u为起点的边，对每一条
 边进行松弛操作。例如存在一条从u到v的边，那么可以通过将边u->v添加到尾部来拓展一条从s到v的路径，这条路径的长度是
 dis[u]+e[u][v]。如果这个值比目前已知的dis[v]的值要小，我们可以用新值替代当前dis[v]中的值。
・重复第三部，如果集合Q为空，算法结束。最终dis数组中的值就是源点到所有顶点的最短路径。

*/

#include <stdio.h>
int main()
{
	int e[10][10], dis[10], book[10], i, j, n, m, t1, t2, t3, u, v, min;
	int inf = 99999999;//用inf（infinity）存储一个我们认为的正无穷值

	//读入n和m，n表示顶点个数，m表示边的条数
	scanf_s("%d %d",&n,&m);

	//初始化
	for (i = 1; i <= n; i++)
		for (j = 1; j <= n; j++)
			if (i == j) e[i][j] = 0;
			else e[i][j] = inf;

	//读入边
	for (i = 1; i <= m; i++)
	{
		scanf_s("%d %d %d",&t1,&t2,&t3);
		e[t1][t2] = t3;
	}

	//初始化dis数组，这里是1号顶点到其他各顶点的初始路程
	for (i = 1; i <= n; i++)
		dis[i] = e[1][i];
	//book数组初始化
	for (i = 1; i <= n; i++)
		book[i] = 0;
	book[1] = 1;

	//Dijkstra算法核心语句
	for (i = 1; i <= n-1; i++)
	{
		//找到离1号顶点最近的顶点
		min = inf;
		for (j = 1; j <= n; j++)
		{
			if (book[j] == 0 && dis[j] < min)
			{
				min = dis[j];
				u = j;
			}
		}
		book[u] = 1;
		for (v = 1; v <= n; v++)
		{
			if (e[u][v] < inf)
			{
				if (e[u][v] < inf)
				{
					if (dis[v] > dis[u] + e[u][v])
						dis[v] = dis[u] + e[u][v];
				}
			}
		}

		//输出最终结果
		for (i = 1; i <= n; i++)
			printf("%d",dis[i]);

		getchar();
		getchar();
		return 0;

	}
}